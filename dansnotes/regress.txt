
patch to vbmakeglm to do the right thing for non-autocorrelated data

NEW LIST OF STEPS (and dependencies)
-----------------
makefilter               nothing
makenoisemodel           nothing
KG                       G,exofilt (why not K???)
K                        filter,noisemodel
F1                       KG
V                        K
R                        F1
RV                       R,V
RVRV                     RV
traces                   RVRV
regression               F1(if calculated),R,exofilt,traces
F3                       V,KG
regressmerge             regress
audit                    all, IDL-DEPENDENT!
resid                    prm (regression)
smoothness estimate      resid

OUT: pre-calculate ps volumes

CALCULATING STATS
-----------------
t
  fact=cF1F3c  (first element)
  error=sqrt((SSE/tracerv)*fact)
  t=cB/error (also returns effdf)
t(non-autocorrelated)
  same as the above, but K=ident and V=ident, so...
  F1F3 reduces to invert(GtG) and
  fact=c(invert(GtG))c
  tracerv=trace(R)
F
  a little more complicated
Intercept
  cB/Intercept
Beta
  cB
S/N
  cB/Error [not fact-corrected?]

LIST OF STEPS
-------------
make KG -- scale exofilt and convolve columns of G [stand_alone]
make F1 -- pinv(KG) [matpinv]
make R -- I-(KG)(F1) [matimxy]
regstart -- [stand_alone]
regstep -- [stand_alone in pieces]
assembleps -- [jobtype assembleps]
genautocormodel -- DOES NOTHING AT PRESENT! [idl]
makematk -- [stand_alone] [NOTE: DONE WELL AFTER KG???]
make V -- KKt [matxxt in pieces]
make F3 -- V*KG*invert(KGtKG)   [idl]
make RV -- [matxy in pieces]
make RVRV -- [matxx]
comptraces -- [stand_alone]
regfinish -- [stand_alone]
audit -- [idl]

OLD LIST OF WHAT THE GLM SEQUENCES DO (should be similar!)
-------------------------
- make the KG matrix    [=a function of G and exofilt]
- make the F1 matrix    [=invert(KGtKG)##KGt]
- make the R matrix     [=a function of KG and F1]
- tesregressstart
- tesregresssteps (parallel)
- assemble residual ps
- create autocorrelation model
- create K matrix       [=some function of intrincor and exofilt]
- create V matrix (parallel)
- create F3     [=V##KG##invert(KGtKG)]
- create RV (parallel)
- create RVRV (parallel)
- do the traces [=traces of RV and RVRV]
- finish the regression [scales error term, which depends on traces, and uses residmaps]
- audit [depends on finished regression]
- notify

TESREGRESSSTEP
--------------
-  get the list of tes files from the sub file
-  figure out where the time series is in each file
-  load up the g matrix
-  load up f1
-  load up r
-  load up exofilt
-  kernel=fourier(exofilt), kernel(0)=(1,0)
-  if we're excluding error, then load up tracerv
-  for each space point:
   - load up the time series
   - calculate the betas, storing the residuals
   - grab the power spectrum of the residuals
   - write out the betas and the residuals

[calculatebetas2]
- kx=convolve signal with exokernel
- betas=f1**transpose(kx)
- res=r**transpose(kx)
- errorsq=Rt**R
- return betas and errorsq

[calculatebetas_no_temporality]
X=signal
G=g matrix
BETAS=pinv(G)*X
resids=X-GB, or something like that
tack uncorrected sum squared error onto betas vector

MakeMatrixKG
------------
exofilt=sqrt(returnps(exofilt))
exofilt=exofilt/max(exofilt)
exofilt(0)=1
for each column in g:
  col=float(ifft(fft(col)*exofilt))
write it out!

new useful matrix: makematrixfoo
foo=invert(transpose(KG)##KG)

MakeMatrixF1
------------
F1=pinv(kg)=invert(transpose(KG)##KG)##transpose(KG)

MakeMatrixF3
------------
F3=V##KG##invert(transpose(KG)##KG)




  // calculation of the average full PS and the average redidual PS
  // can take place in an extrenal program, thusly:
  //   signalVector.meanCenter();
  //   signalVector.getPS();
  //   signalVector /= (double ) nonZeros.size();
  //   avgFullPS = avgFullPS + signalVector;
  
  //   VB_Vector tempResid = residuals;
  //   tempResid.getPS();
  //   tempResid /= nonZeros.size();
  //   avgResidPS = avgResidPS + tempResid;


// SincRezize re-implements the old IDL sincinterpo function

ColumnVector
SincResize(ColumnVector vec,double factor)
{
  if (factor == 1.0)
    return vec;
  ColumnVector newcv((int)(vec.length()*factor));
  if (factor < 1) {
    for (int i=0; i<newcv.length(); i++)
      newcv(i)=InterpolatedElement(vec,(double)i/factor);
    return newcv;
  }

  float timeshift;
  int length,i,j,k;
  int lastfront,firstback,midpoint;
  double twopi=atan(1)*8.0;

  length=vec.length();
  if (vec.length()%2) {
    midpoint=lastfront=length/2;
    firstback=length/2+1;
  }
  else {
    lastfront=length/2-1;
    midpoint=length/2;
    firstback=length/2+1;
  }

  for (i=0; i<factor; i++) {
    timeshift=(float)i/factor;
    ColumnVector phi(length);
    phi(0)=0.0;
    for (int f=1;f<=midpoint; f++)
      phi(f)=timeshift*twopi/((float)length/float(f));
    for (j=lastfront,k=firstback; k<length; j--,k++)
      phi(k)=0.0-phi(j);
    //    cout << "phi " << phi << endl;
    ComplexColumnVector shifter(phi.length());
    for (j=0; j<phi.length(); j++)
      shifter(j)=Complex(cos(phi(j)),sin(phi(j)));
    ComplexMatrix fftsig=((ComplexMatrix)vec).fourier();
    fftsig = product(fftsig,(ComplexMatrix)shifter);
    ComplexMatrix shiftedsignal=fftsig.ifourier();
    for (j=0; j<length; j++)
      newcv((int)(j*factor+i))=shiftedsignal(j,0).real();
  }
  return newcv;
}

